# 树

## 根据序列建树

### 前序后序建树（多结果）

#### 建树方法

>前序：SACEFBDGHIJK
后序：CFEABHGIKJDS

由前序序列正向找到根`S`，去后序序列中寻找该根 *CFEABHGIKJD**S***，寻找后序序列中该节点前***CFEABHGIKJD**S* 是否存在前序序列中该节点后 *S**ACEFBDGHIJK*** 的元素，存在则前序序列的下一元素`A`为孩子，并将其作为新的根节点。若后序序列中该节点前不存在其他未排序元素，则该节点为叶子节点，前序序列下一个元素为上一级根的新的孩子。重复以上

>               S
>              /
>             A

`root==A`  ***CFE**ABHGIKJDS* *SA**CEF**BDGHIJK*
C为左孩子

>               S
>              /
>             A
>            /
>           C

后序中`C`前不存在其他未排序元素（后序：左右根，说明C没孩子节点），C为叶子节点
前序序列下一元素为`E`，后序中E前有F，F前无其他，F为叶子

>               S
>              /
>             A
>            / \
>           C   E
>                \
>                 F

前序下一元素`B`在根节点`A`的后面，寻找`A`的父节点`S`，B是S的孩子
后序中B前无其他，B为叶子

>               S
>             / |
>            A  B
>           / \
>          C   E
>               \
>                F

重复可得

>                  S
>               /  |  \
>            A     B     D
>           / \        / | \
>          C   E      G  I  J
>               \    /       \
>                F  H         K

#### 多解

共有**2^n^**个可能的树。因所有的独生子女节点（不存在兄弟节点）均不能确定是左孩子还是右孩子，**`n`**为独生子女节点的个数，上图中，`F` `H` `K`均为独生子女节点，共有`8`种可能的树